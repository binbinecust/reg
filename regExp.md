title: 正则表达式
speaker: 方彬彬
transition: slide3
theme: dark

[slide]
## 主题：正则表达式
## 作者：方彬彬
## 时间：2018-08-10

[slide]
## 内容大纲
* 基本语法
* 在js中的应用
* 贪婪匹配与非贪婪匹配
* 位置匹配
* 分组
* 回溯
* 读正则

[slide]
## 基本语法
---
 | base                                                          | single char                              | quantifiers(数量)                                              | position(位置)                               |
 | :------------------------------------------------------------ | :--------------------------------------- | :------------------------------------------------------------- | :------------------------------------------- |
 | []字符集合（里面的任何内容表示字符本身）                      | \d === [0-9] 匹配数字                    | * 0个或者更多                                                  | ^一行的开头                                  |
 | [^]对字符集合取非                                             | \D === [^0-9] 非数字                     | + 1个或更多，至少1个                                           | $一行的结尾                                  |
 | [-]定义一个区间                                               | \w  匹配word(数字、字母) [0-9a-zA-Z\_]   | ? 0个或1个,一个Optional (跟在*，+，{}后会让匹配变为非贪婪模式) | \b 单词"结界"(word bounds) \B 匹配非单词边界 |
 | 逻辑或字符                                                    | \W 匹配非word(数字、字母) [^0-9a-zA-Z\_] | {min,max}出现次数在一个范围内                                  | \B：匹配非单词边界                           |
 | \在非特殊字符之前的反斜杠表示下一个字符是特殊的或者是进行转义 | \s [\t\v\n\r\f]                          | {n}匹配出现n次的                                               | (?=p) 匹配 p 前面的位置                      |
 | . 匹配任何，任何的字符，除了换行符                            | \S [^\t\v\n\r\f]                         |                                                                | (?!p) 匹配不是 p 前面的位置                  |

[slide]
## js中的应用
* 字符串方法
  * search 
  
    接受一个正则作为参数 如果参入的参数不是正则会隐式的使用 `new RegExp(obj)`

    将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1

  * match
  
      接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，
      
      那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会
      
      返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的
      
      是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，
      
      input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹
      
      配结果
      
      `'For more information, see Chapter 3.4.5.1'.match(/see (chapter \d+(\.\d)*)/i)`;
      `'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.match(/[A-E]/gi)`;

[slide]
* 字符串方法
  * replace
  
    接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串;
    例子：驼峰转下划线 'look_x_admin'.replace(/_(\w)/g, ($0,$1) => $1.toUpperCase());
    'lookXAdmin'.replace(/[A-Z]/g, ($0) => '_'+$0.toLowerCase());

  * split
  
    接受两个参数，返回一个数组 
    "Hello,My name is Vincent. Nice to Meet you!What's your name?Haha." .split(/[,\s.]+/g);

[slide]
* 正则的方法
  * test
  * exec
  /\b(\d+)\b/g.exec('2018.08.10')   只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。

[slide]
## 贪婪匹配与非贪婪匹配
* 默认贪婪
* 加？表示非贪婪(惰性)
"123 1234 12345 123456".match(/\d{2,5}/g);
"123 1234 12345 123456".match(/\d{2,5}?/g);
"goodbye".match(/good|goodbye/g); // ['good'];

[slide]
## 位置匹配
hello *h*e*l*l*o*
<img src="/assets/hello.png" height="450">
'hello word [js]_reg.exp-01'.replace(/\b/g, '#') // #hello# #word# [#js#]#_reg#.#exp#-#01#
'hello'.replace(/(?=l)/g, '#') // he#l#lo
'hello'.replace(/(?!l)/g, '#') //#h#ell#o#
字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 ''
'' + '' + '' + '' + 'h' + 'e' + 'l' + 'l' + 'o' + '' // /^^^h\B\B\Be\Bl\Bl\Bo$$$/.test('hello');
'1234567890'.replace(/(?=(\d{3}))+/g, ',')  /(?!^)(?=(\d{3})+$)/g  思考：/\d(?=(\d{3})+$)/g 能匹配到吗？
结论：如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置；

[slide]
## 分组（）
### 分组和分支结构
在分支结构中，括号是用来表示一个整体的，(p1|p2)
/(abc)+/ 
'I love beijing'.match(/^I love (beijing|shanghai)$/)

[slide]
### 分组引用
* 提取数据
  /\d{4}-\d{2}-\d{2}/ => yyyy-mm-dd 
  match exec RegExp.$1 RegExp.$2
* 替换
  replace $1-$9
"2017-08-09".replace(/\d{4}-\d{2}-\d{2}/, "$2/$3/$1");
"2017-08-09".replace(/(\d{4})-(\d{2})-(\d{2})/, ($0, $1, $2, $3) => `${$2}/${$3}/${$1}`);

[slide]
### 反向引用
2017-08-09

2017/08/09

2017.08.09
/(\d{4})[-/.](\d{2})[-/.](\d{2})/
反向引用可以在匹配阶段捕获到分组的内容

/(\d{4})([-/.])(\d{2})\2(\d{2})/

如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\1就匹配\1

examples:
https://www.baidu.com?name=jawil&age=23
function getParams(url, attr) {
  let match = RegExp(`[?&]${attr}=([^&]*)`).exec(url);
  return match[1];
}

[slide]
## 回溯
### 正则是怎么匹配的
/ab{1,3}bbc/.test('abbbc')
<img src="/assets/back.png" height="450">
贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个

分支结构也会产生回溯，比如/^(test|te)sts$/.test('tests')

[slide]
## 读正则
结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。
操作符：

转义符 \
括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...]
量词限定符 {m}、{m,n}、{m,}、?、*、+
位置和序列 ^ 、$、 \元字符、 一般字符
管道符（竖杠） |

操作符的优先级是从上到下，由高到低的
/ab?(c|de*)+|fg/
画一个图出来 https://jex.im/regulex/


  ---
  
| 变量名 | 代表的值                                                                                   |
| :----- | :----------------------------------------------------------------------------------------: |
| $$     | 插入一个 "$"                                                                               |
| $&     | 插入匹配的子串                                                                             |
| $`     | 插入当前匹配的子串左边的内容                                                               |
| $n     | 假如第一个参数是 RegExp对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串 |