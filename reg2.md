title: 正则表达式
speaker: 方彬彬
transition: slide3
theme: dark

[slide]
## 主题：正则表达式
## 作者：方彬彬
## 时间：2018-08-10

[slide]
## 内容大纲
* 基本语法
* 在js中的应用
* 贪婪匹配与非贪婪匹配
* 位置匹配
* 分组
* 回溯
* 读正则

[slide]
## 基本语法
---
 | base                                                          | single char                              | quantifiers(数量)                                              | position(位置)                                         |
 | :------------------------------------------------------------ | :--------------------------------------- | :------------------------------------------------------------- | :----------------------------------------------------- |
 | []字符集合（里面的任何内容表示字符本身）                      | \d === [0-9] 匹配数字                    | * 0个或者更多                                                  | ^一行的开头                                            |
 | [^]对字符集合取非                                             | \D === [^0-9] 非数字                     | + 1个或更多，至少1个                                           | $一行的结尾                                            |
 | [-]定义一个区间                                               | \w  匹配word(数字、字母) [0-9a-zA-Z\_]   | ? 0个或1个,一个Optional (跟在*，+，{}后会让匹配变为非贪婪模式) | \b 单词"结界"(word bounds) \B 匹配非单词边界           |
 | 逻辑或字符                                                    | \W 匹配非word(数字、字母) [^0-9a-zA-Z\_] | {min,max}出现次数在一个范围内                                  | \B：匹配非单词边界                                     |
 | \在非特殊字符之前的反斜杠表示下一个字符是特殊的或者是进行转义 | \s [\t\v\n\r\f]                          | {n}匹配出现n次的                                               | (?=p) 匹配 p 前面的位置                                |
 | . 匹配任何，任何的字符，除了换行符                            | \S [^\t\v\n\r\f]                         |                                                                | (?!p) 匹配不是 p 前面的位置    (?< p) 匹配p 后面的位置 |

[slide]
## js中的应用
* 字符串方法
  * search {:&.rollIn}
  * match
  * replace ($0-$100)

  `'look_x_admin'.replace(/_(\w)/g, ($0,$1) => $1.toUpperCase()) // lookXAdmin` {:&.rollIn}

  `'lookXAdmin'.replace(/[A-Z]/g, ($0) => '_'+$0.toLowerCase());` {:&.rollIn}

  * split {:&.rollIn}

  `"Hello,My name is Vincent. Nice to Meet you!What's your name?Haha." .split(/[,\s.]+/g)` {:&.rollIn}

[slide]
* 正则的方法
  * test
  * exec

  ```
  var string = "2017.06.27";
  var regex2 = /\b(\d+)\b/g;
  var result;
  while ( result = regex2.exec(string) ) {
      console.log( result, regex2.lastIndex );
  }
  // => ["2017", "2017", index: 0, input: "2017.06.27"] 4
  // => ["06", "06", index: 5, input: "2017.06.27"] 7
  // => ["27", "27", index: 8, input: "2017.06.27"] 10
  ```   
  
  ps: 只是有 g 标识的时候可以反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。 {:&.rollIn}

[slide]
## 正则匹配

* 字符匹配 {:&.rollIn}

`'hello world'.match(/hello/)` {:&.rollIn}

* 数量匹配 {:&.rollIn}

* 多种情况的匹配 {:&.rollIn}
  
`ps：贪婪匹配和非贪婪匹配` {:&.rollIn}

<img src="/assets/greedy.png" height="150"> {:&.rollIn}



[slide]
* 位置匹配

<img src="/assets/hello.png" height="100"> {:&.rollIn}


<img src="/assets/test.png" height="100"> {:&.rollIn}

字符与字符之间的位置可以是多个。在理解上可以将位置理解成空字符串 '' {:&.rollIn}

'' + '' + '' + '' + 'h' + 'e' + 'l' + 'l' + 'o' + '' // /^^^h\B\B\Be\Bl\Bl\Bo$$$/.test('hello'); {:&.rollIn}

'1234567890'.replace(/(?=(\d{3}))+/g, ',')  /(?!^)(?=(\d{3})+$)/g  思考：/\d(?=(\d{3})+$)/g 能匹配到吗？ {:&.rollIn}

结论：如果要求一个正则是匹配位置的话，那么所有的条件必须都是位置； {:&.rollIn}

[slide]
## 分组
### 分组和分支结构
在分支结构中，括号是用来表示一个整体的，(p1|p2)
/(abc)+/ 
'I love beijing'.match(/^I love (beijing|shanghai)$/)

[slide]
### 分组引用
* 提取数据 {:&.rollIn}
  
  /\d{4}-\d{2}-\d{2}/ => yyyy-mm-dd 

  match exec RegExp.$1 RegExp.$2 {:&.rollIn}

* 替换
  
  replace $1-$9

`"2017-08-09".replace(/\d{4}-\d{2}-\d{2}/, "$2/$3/$1");` {:&.rollIn}

`"2017-08-09".replace(/(\d{4})-(\d{2})-(\d{2})/, ($0, $1, $2, $3) => $2+'/'+$3+'/'+$1);` {:&.rollIn}

[slide]
* 反向引用 {:&.rollIn}
```
2017-08-09 2017/08/09 2017.08.09 
/(\d{4})[-/.](\d{2})[-/.](\d{2})/
```

反向引用可以在匹配阶段捕获到分组的内容 {:&.rollIn}

`/(\d{4})([-/.])(\d{2})\2(\d{2})/` {:&.rollIn}

如果在正则里面引用了前面不存在的分组，这个时候正则会匹配字符本身，比如\1就匹配\1  {:&.rollIn}

[slide]
## 回溯

* 正则是怎么匹配的
  
`/ab{1,3}bbc/.test('abbbc')`

<img src="/assets/back.png" height="450">

[slide]
贪婪和非贪婪的匹配都会产生回溯，不同的是贪婪的是先尽量多的匹配，如果不行就吐出一个然后继续匹配，
再不行就再吐出一个，非贪婪的是先尽量少的匹配。如果不行就再多匹配一个，再不行就再来一个
分支结构也会产生回溯，比如/^(test|te)sts$/.test('tests')

[slide]
## 读正则
* 结构：字符字面量、字符组、量词、锚字符、分组、选择分支、反向引用。
* 操作符：
  
  转义符 \

  括号和方括号 (...)、(?:...)、(?=...)、(?!...)、[...]

  量词限定符 {m}、{m,n}、{m,}、?、*、+

  位置和序列 ^ 、$、 \元字符、 一般字符

  管道符（竖杠） |

操作符的优先级是从上到下，由高到低的

/ab?(c|de*)+|fg/

<img src="/assets/show.png" height="250"> {:&.rollIn}

[slide]
## 经典示例
* 验证密码 /((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))^[0-9A-Za-z]{6,12}$/
* 去除文本首尾空白字符 str.replace(/^\s+|\s$/g, '')
* 日期字符匹配 /\d{4}-(0?[1-9]|1[012])-(0?[1-9]|[12][0-9]|3[01])/
* 匹配路径 /\/([^\/:*%<>|"?\r\n]+\/)*[^\/:*%<>|"?\r\n]+\/?/ windows /[a-zA-Z]:\\([^\/:*<>|"?\r\n]+\\)*[^\/:*<>|"?\r\n]+\\?/
* 匹配URL /(https?|ftp):\/\/[^/?:]+(:[0-9]{1-5})?(\/?|(\/[^/]+)*(\?[^\s"']+)?)/
* 匹配成对的HTML Tag /<([a-z][a-z0-9]*)(?=[\s>])('[^']*'|"[^"]*"|[^'">])*>.*?<\/\1>/
  
[slide]
推荐书籍：《JavaScript 正则表达式迷你书》
推荐可视化工具：https://regexper.com/

